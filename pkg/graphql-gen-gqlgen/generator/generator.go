package generator

import (
	"bytes"
	"go/build"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"

	"github.com/99designs/gqlgen/codegen/config"
	"github.com/samlitowitz/graphqlc/pkg/graphqlc/compiler"
)

// A GoImportPath is the import path of a Go package. e.g., "google.golang.org/genproto/protobuf".
type GoImportPath string

func (p GoImportPath) String() string { return strconv.Quote(string(p)) }

// A GoPackageName is the name of a Go package. e.g., "protobuf".
type GoPackageName string

type common struct {
	file *FileDescriptor
}

func (c *common) GoImportPath() GoImportPath {
	return c.file.importPath
}

func (c *common) File() *FileDescriptor { return c.file }

type EnumDescriptor struct{}

type InterfaceDescriptor struct{}

type StructDescriptor struct{}

type FileDescriptor struct {
	// MODEL FILE GENERATION
	// imports
	// interfaces (GraphQL interfaces and unions)
	// structs (GraphQL input objects and objects)
	// enums (GraphQL enums)

	// RESOLVER FILE GENERATE
	// imports
	// typed resolver struct

	exported map[Object][]symbol

	name        string
	importPath  GoImportPath
	packageName GoPackageName
	doNotEdit   bool // Add do not edit warning
}

type symbol interface {
	GenerateAlias(g *Generator, filename string, pkg GoPackageName)
}

type Object interface {
	GoImportPath() GoImportPath
	TypeName() string
	File() *FileDescriptor
}

type Generator struct {
	*bytes.Buffer
	Request  *compiler.CodeGeneratorRequest  // The input
	Response *compiler.CodeGeneratorResponse // The output

	Param map[string]string // Command-line parameters

	gqlgenConfig *config.Config // gqlgen configuration
	genFiles     []*FileDescriptor

	gopaths []string // All src/ directories in default and defined gopaths
}

func New() *Generator {
	g := new(Generator)
	g.Buffer = new(bytes.Buffer)
	g.Request = new(compiler.CodeGeneratorRequest)
	g.Response = new(compiler.CodeGeneratorResponse)

	g.gopaths = filepath.SplitList(build.Default.GOPATH)
	for i, p := range g.gopaths {
		g.gopaths[i] = filepath.ToSlash(filepath.Join(p, "src"))
	}

	return g
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("graphqlc-gen-test: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("graphqlc-gen-test: error:", s)
	os.Exit(1)
}

func (g *Generator) CommandLineArguments(parameter string) {
	g.Param = make(map[string]string)
	for _, p := range strings.Split(parameter, ",") {
		if i := strings.Index(p, "="); i < 0 {
			g.Param[p] = ""
		} else {
			g.Param[p[0:i]] = p[i+1:]
		}
	}

	for k, v := range g.Param {
		switch k {
		case "config":
			config, err := config.LoadConfig(v)
			if err != nil {
				g.Error(err)
			}
			g.gqlgenConfig = config
		}
	}
	// Use default config if no config provided
	if g.gqlgenConfig == nil {
		g.gqlgenConfig = config.DefaultConfig()
	}
	// We've only parsed files to generate, let's not touch anything else
	g.gqlgenConfig.SchemaFilename = g.Request.FileToGenerate
}

func (g *Generator) WrapTypes() {
	g.genFiles = make([]*FileDescriptor, 0)

	if g.gqlgenConfig.Model != (config.PackageConfig{}) {
		fd, err := wrapPackageConfig(&g.gqlgenConfig.Model, g.gopaths)
		if err != nil {
			g.Error(err)
		}
		fd.doNotEdit = true
		g.genFiles = append(g.genFiles, fd)
	}

	if g.gqlgenConfig.Resolver != (config.PackageConfig{}) {
		fd, err := wrapPackageConfig(&g.gqlgenConfig.Resolver, g.gopaths)
		if err != nil {
			g.Error(err)
		}
		g.genFiles = append(g.genFiles, fd)
	}

	if g.gqlgenConfig.Exec != (config.PackageConfig{}) {
		fd, err := wrapPackageConfig(&g.gqlgenConfig.Exec, g.gopaths)
		if err != nil {
			g.Error(err)
		}
		fd.doNotEdit = true
		g.genFiles = append(g.genFiles, fd)
	}
}

func wrapPackageConfig(cfg *config.PackageConfig, gopaths []string) (*FileDescriptor, error) {
	importPath, err := buildImportPath(filepath.Dir(cfg.Filename), gopaths)
	if err != nil {
		return nil, err
	}
	packageName := GoPackageName(cfg.Package)
	if packageName == "" {
		packageName = GoPackageName(filepath.Base(string(importPath)))
	}

	return &FileDescriptor{
		name:        cfg.Filename,
		importPath:  importPath,
		packageName: packageName,
	}, nil
}

func (g *Generator) GenerateAllFiles() {
	for _, fd := range g.genFiles {
		g.Reset()

		g.generate(fd)
		g.Response.File = append(g.Response.File, &compiler.CodeGeneratorResponse_File{
			Name:    fd.name,
			Content: g.String(),
		})
	}
}

func (g *Generator) generate(fd *FileDescriptor) {
	if fd.doNotEdit {
		g.WriteString("// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.\n\n")
	}
	g.WriteString("package " + string(fd.packageName) + "\n")
}

func buildImportPath(dir string, gopaths []string) (GoImportPath, error) {
	cwd, err := filepath.Abs(dir)
	if err != nil {
		return "", err
	}
	cwd = filepath.ToSlash(cwd)
	checkedPath := ""
	for {
		goMod, err := ioutil.ReadFile(filepath.Join(cwd, "/", "go.mod"))
		if err == nil {
			return GoImportPath(filepath.Join(string(regexp.MustCompile("module (.*)\n").FindSubmatch(goMod)[1]), checkedPath)), nil
		}

		checkedPath = filepath.Join(filepath.Base(cwd), checkedPath)
		cwd, err = filepath.Abs(filepath.Join(cwd, ".."))
		if err != nil {
			return "", err
		}

		if cwd == "/" {
			break
		}
	}

	for _, gopath := range gopaths {
		gplen := len(gopath)
		if gplen < len(dir) && strings.EqualFold(gopath, dir[0:gplen]) {
			return GoImportPath(dir[gplen+1:]), nil
		}
	}

	return "", nil
}
